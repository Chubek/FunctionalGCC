# EBNF Grammar for Standard ML; Revision '97
# Source: "The Definition of Standard ML - Revised by Robin Milner, Robert Harper, David McQueen etc. --- MIT Press"

# A: Expressions and Matches

application ::= expression { expression }         # Application
             | module-declaration

expression ::= constant
           | [ operator ] long-identifier
           | '{' row
                  { ',' row } '}'                 # Record Initializer
           | '#' identifier                      # Record Selector
           | "()"                                # Unit
           | '(' expression ',' { ',' expression } ')'  # n-tuple
           | '[' [ expression { ',' expression } ] ']'  # List
           | '(' [ expression { ',' expression } ] ')'  # Sequence
           | "let" declaration 
                  "in" expression { expression } "end"  # Local Declaration
           | '(' expression ')'                   # Grouped Expression
           | infix-expression                     # Infix Expression
           | ref-expression                       # Reference Expression
           | deref-expression                     # Dereference Expression
	   | functor-expression			  # Functor Expression
	   | struct-expression			  # Structure Expression

row ::= identifier '=' expression                # Expression Row

ref-expression ::= "ref" ( long-identifier  | constant )
deref-expression ::= "!" long-identifier

infix-expression ::= postfix-expression            # Base Infix
               | infix-expression
                  { identifier infix-expression } # Infix Expression

postfix-expression ::= [ identifier ] solo-expression  # Base Postfix

solo-expression ::= infix-expression
               | solo-expression ':' type          # Type Restriction
               | solo-expression "andalso" solo-expression  # Conjunction
               | solo-expression "orelse" solo-expression   # Disjunction
               | solo-expression "handle" match-situation   # Exception Handling
               | "raise" solo-expression             # Exception Raising
               | "if" solo-expression
                  "then" solo-expression 
                  "else" solo-expression             # Conditional
               | "while" solo-expression 
                  "do" solo-expression               # Iteration
               | "case" solo-expression 
                  "of" match-situation               # Case Analysis
               | "fn" match-situation                # Function

match-situation ::= match-rule { '|' match-rule }  # Match Situation

match-rule ::= pattern "=>" pattern                # Match Pattern

declaration ::= val-declaration
             | fun-declaration
             | "infix" [ int-literal ] [ identifier ] identifier
             | "infixr" [ int-literal ]  [ identifier ] identifier
             | "nonfix" [ int-literal ] [ identifier ] identifier

val-declaration ::= "val" val-binding { "and" val-binding }  # Value Binding Declaration

fun-declaration ::= "fun" [ "rec" ] 
               fun-binding { "and" fun-binding }   # Function Binding Declaration

val-binding ::= pattern '=' expression            # Value Binding

fun-binding ::= pattern '=' expression            # Function Binding

type ::= type-constructor
      | type-variable
      | type '(' type { ',' type } ')'           # Type Constructor Application
      | type "->" type                           # Function Type

pattern ::= identifier
         | '_'                                    # Wildcard Pattern
         | '(' pattern ',' { ',' pattern } ')'    # Tuple Pattern
         | '[' pattern { ',' pattern } ']'        # List Pattern
         | type-constructor pattern               # Type Constructor Pattern

type-constructor ::= long-identifier              # Type Constructor

type-variable ::= identifier                      # Type Variable

constant ::= int-literal
         | float-literal
         | string-literal
         | char-literal
         | bool-literal

# B: Module System

module-declaration ::= "structure" long-identifier
                  | "functor" long-identifier functor-arg-spec
                    "=>" long-identifier
                  | "local" struct-level-declaration
                    "in" struct-level-declaration
                    { struct-level-declaration }
                    "end"

struct-level-declaration ::= long-identifier
                    | struct-level-declaration
                      long-identifier
                      { struct-level-identifier }
                      '=' struct-expression

functor-arg-spec ::= '(' functor-arg-decl { ',' functor-arg-decl } ')'
                 | '(' functor-arg-decl { ',' functor-arg-decl } ')' ':' long-identifier

functor-arg-decl ::= long-identifier
               | '(' functor-arg-decl { ',' functor-arg-decl } ')' ':' long-identifier

struct-expression ::= long-identifier
                | "struct" { struct-level-declaration } "end"
                | '(' struct-expression ',' { ',' struct-expression } ')'

long-identifier ::= long-value-identifier

struct-level-identifier ::= long-value-identifier

signature-declaration ::= "signature" long-identifier
                   | "where" long-identifier
                     "sig" { signature-declaration } "end"

spec-expression ::= long-identifier
              | "struct" { spec-level-declaration } "end"
              | '(' spec-expression ',' { ',' spec-expression } ')'

spec-level-declaration ::= long-identifier
                   | spec-level-declaration
                     long-identifier
                     { spec-level-identifier }
                     '=' spec-expression

functor-declaration ::= "functor" long-identifier functor-arg-spec
                 | "where" long-identifier
                   "fun" { functor-declaration } "end"

functor-arg-spec ::= '(' functor-arg-decl { ',' functor-arg-decl } ')'
                 | '(' functor-arg-decl { ',' functor-arg-decl } ')' 
				':' long-identifier

functor-arg-decl ::= long-identifier
               | '(' functor-arg-decl { ',' functor-arg-decl } ')' 
	      			':' long-identifier

functor-binding ::= long-identifier
              | "struct" { struct-level-declaration } "end"
              | '(' functor-binding ',' { ',' functor-binding } ')'
              | functor-binding long-identifier '=' functor-expression

functor-expression ::= long-identifier
                | "struct" { struct-level-declaration } "end"
                | '(' functor-expression ',' { ',' functor-expression } ')'
                | long-identifier '(' functor-binding { ',' functor-binding } ')'
                | "fn" functor-arg-decl "=>" functor-expression

functor-arg-decl ::= long-identifier
               | '(' functor-arg-decl { ',' functor-arg-decl } ')' ':' long-identifier

long-identifier ::= identifier { '.' identifier }

# C. Lexical Considerations

identifier ::= letter { letter | digit | '_' }

int-literal ::= [ '-' ] digit { digit }

float-literal ::= [ '-' ] digit { digit } "." digit { digit }

string-literal ::= '"' { character } '"'

char-literal ::= "'" character "'"

bool-literal ::= "true" | "false"

digit ::= '0' | '1' | '2' | ... | '9'

letter ::= 'A' | 'B' | 'C' | ... | 'Z' | 'a' | 'b' | 'c' | ... | 'z'

